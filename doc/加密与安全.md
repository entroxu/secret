### 加密与安全

Bob给Alice发送一封邮件，在这过程中黑客可能会窃取信件内容、篡改信件、甚至黑客可能会伪造一封来自Bob的邮件。

因此，在信息交互的过程中，需要防止以上三种情况出现，即：

* 防窃听
* 防篡改
* 防伪造

计算机加密技术主要就是为了实现这几个目标，现代计算机密码学是建立在严格的数学理论基础上的。
而好的加密算法也是不断迭代修补i漏洞才逐渐完善的，因此自己设计一个安全加密算法是不可靠的，而验证一个加密算法是安全需要用不断证伪的过程，目前认为安全的加密算法仅仅是目前尚未攻破而以。


与加密（广义）相关的常见算法有以下几种：

#### 1. 编码

##### 1.1 ASCII 
如计算机最基本的编码：ASCII就是一种编码（可以看成一个字节的utf-8,最高为0）

| 字符  |ASCII编码|
|-----|---|
| A   | ox41 |
| B   | ox42 |
| …   | … |

标准ASCII因为是单字节（1byte=8bit）编码，同时，最高位b7作为奇偶校验位，因此最多只能编码2^7=128个字符(包括部分功能字符，如换行、回车)。

##### 1.2 utf-8
为了编码中字符及更多的字符集（比如Unicode），则需要使用更多的位数来编码，如utf-8,作为一种unicode实现，因为其兼容ASCII码，因此成为广泛使用的实际标准，它是一种可变编码使用1-4个字节编码。

这种变长编码方式的优点是节省空间，坏处是不能根据字符个数直接计算出字节数。

##### 1.3 url编码
需要url编码的主要原因是出于兼容性考虑。很多底层中间服务只识别ASCII字符，因此url中包含的非ASCII编码就需要被url编码.
url编码的主要规则是

* 如果字符是`a-z,A-Z,0-9`及`-,_,.,*`则保持不变.
* 如果是其他字符则先转成utf-8编码，然后在每个字节前加上%，例如一的utf-8编码是`0xe4b880`,因此它的Url编码是`%E4%B8%80`.Url编码总是大写.

##### 1.4 base64
url编码是用来对字符编码，而base64则是对二进制编码，使之可以用文本表示。

base64可以把任意长度二进制编码成纯文本，且只包含`a-z,A-Z,0-9,+,/,=`这些字符.

base64的编码规则是：
* 把3字节的二进制数据按照6bit一组，用4个int整数表示，然后查表，把int整数用索引对应到字符，然后得到编码后的字符串.
* 如果byte[]输入的长度不是3的整数倍则在输入末尾补一个或两个`0x00`,编码结束后，在结尾加一个或者两个`=`表示补充了一个`0x00`或者补充了两个`0x00`.

实际上，因为编码后的长度加上=总是4个倍数，所以不加也能计算出原始输入的byte[].所以在java中可以使用`.withoutpadding`来去掉`=`.

标准的base64中含有`+,/,=`这几个字符,不利于在url中传播，因此有一种针对url的base64编码（java中`Base64.getUrlEncoder().encodeToString(s)`）.
它仅仅是把`+`变成`-`，`/`变成`_`.

Base64编码的缺点是传输效率会降低，因为它把原始数据的长度增加了1/3.

#### 2. 哈希

哈希算法又称为摘要算法（Digest）,可以对任意一组数据进行计算，生成一个固定长度的摘要.
它有两个特点：

* 相同的输入一定得到相同的输出
* 不同的输入大概率得到不同的输出

这点和布隆过滤器有些相似.

哈希主要为了验证原始数据是否被篡改.

java中Object的`hashcode()`就是一个哈希算法,hashMap就是基于hashcode定位.

两个相同的字符串永远会计算出相同的哈希，这也是为什么当我们自定义个一个对象的时候覆写`equals()`时必须正确覆写`hashCode()`.

##### 1.1 哈希碰撞

因为哈希的运算原理是摘要，所以一定会产生哈希碰撞。

碰撞并不可怕，我们需要控制的是碰撞的概率，碰撞概率大小决定哈希算法的安全.
一个好的哈希算法必须满足：

* 碰撞概率低
* 不能猜测输出

如果一个哈希算法如下规律，则明显不是一个安全的哈希算法
```
hash("java1")="123"
hash("java2")="124"
hash("java3")="125"
```

常见的哈希算法有`md5,sha-1,sha-2,sha-3`
其中`SHA-224、SHA-256、SHA-512`都是sha-2家族的一员.
sha-1和sha-2有相似的设计，sha-3是sha-3竞赛获胜算法，与前两代sha算法无关.

| 算法      | 输出长度（位） |
|---------|---------|
| MD5     | 128bits |
| SHA-1   | 160bits |
| SHA-256 | 256bits |
| SHA-512 | 512bits |

MD5因为输出长度较短，短时间内破解是可能的，目前已经不推荐使用(王小云-2004碰撞新方法[^1])
sha-1（google-2017产生碰撞的pdf[^2]在安全要求较高的应用上也逐步被淘汰.

Java标准库提供了常用的哈希算法，并且有一套统一的接口，在java中可以使用如下代码生成md5：
```
import java.security.MessageDigest;
…
    MessageDigest md = MessageDigest.getInstance("MD5");
    // 可以多次调用update输入更多数据:
    md.update("1234".getBytes("UTF-8"));
    md.update("5678".getBytes("UTF-8"));
    byte[] result = md.digest(); // 20 bytes:25d55ad283aa400af464c76d713c07ad
```

##### 1.2 哈希算法的用途

1.下载软件的时候，网站常常提供md5、sha-1,供用户对比原始文件是否遭到替换篡改。

在maven的repository中的目录结构
```
spring-boot-2.5.6.jar       spring-boot-2.5.6.pom
spring-boot-2.5.6.jar.sha1  spring-boot-2.5.6.pom.sha1
```
2.哈希算法的另一个重要用途是存储用户口令，密码经过hash加盐计算后，就防止
* 数据库管理员看到用户明文密码
* 数据库一旦泄漏，防止用户明文密码泄漏。

使用哈希口令时要注意彩虹表攻击。

什么是彩虹表？黑客拿到md5需要反推明文，只能暴力破解。
这样需要消耗大量的算力时间。实际可以使用一个与先计算好的常用口令对照表：
```
原文             md5 
12345678        25d55ad283aa400af464c76d713c07ad
passw0rd        bed128365216c019988915ed3add75fb
19700101        570da6d5277a646f6552b8832012f5dc
```
这就是彩虹表.

彩虹表的防御可以针对每个用户产生随即盐值，这样即使用户使用了常用口令，也无法反推原始口令.

###### 1.3 java hash算法使用
上面已经介绍了在java中如何使用md5，如果要使用sha-1则只需要，替换传入的算法名称

```
import java.security.MessageDigest;
…
    MessageDigest md = MessageDigest.getInstance("sha-1");
    // 可以多次调用update输入更多数据:
    md.update("1234".getBytes("UTF-8"));
    md.update("5678".getBytes("UTF-8"));
    byte[] result = md.digest();
```
Java标准库支持的所有哈希算法可以在这里[^3]查到

[^1]:王小云 https://zh.m.wikipedia.org/zh-cn/%E7%8E%8B%E5%B0%8F%E9%9B%B2
[^2]:sha-1 https://zh.wikipedia.org/wiki/SHA-1
[^3]:Java标准库支持的所有哈希算法 https://docs.oracle.com/en/java/javase/14/docs/specs/security/standard-names.html#messagedigest-algorithms